var MapUtil = /** @class */ (function () {
    function MapUtil() {
    }
    MapUtil.TryGetValue = function (map, key, result) {
        var item = map.get(key);
        if (item != null) {
            result(item);
            return true;
        }
        return false;
    };
    return MapUtil;
}());

var Guid = /** @class */ (function () {
    function Guid() {
    }
    Guid.NewGuid = function () {
        if (!Guid.lut) {
            Guid.lut = new Array();
            for (var i = 0; i < 256; i++) {
                Guid.lut[i] = (i < 16 ? '0' : '') + (i).toString(16);
            }
        }
        var lut = Guid.lut;
        var d0 = Math.random() * 0xffffffff | 0;
        var d1 = Math.random() * 0xffffffff | 0;
        var d2 = Math.random() * 0xffffffff | 0;
        var d3 = Math.random() * 0xffffffff | 0;
        return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
        //           // Public Domain/MIT
        // var d = new Date().getTime();
        // if (typeof performance !== "undefined" && typeof performance.now === "function") {
        //     d += performance.now(); //use high-precision timer if available
        // }
        // return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,
        //     function(c) {
        //         const r = (d + Math.random() * 16) % 16 | 0;
        //         d = Math.floor(d / 16);
        //         return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
        //     });
    };
    Guid.Empty = "00000000-0000-0000-0000-000000000000";
    Guid.lut = null;
    return Guid;
}());

var TypeName = /** @class */ (function () {
    function TypeName() {
    }
    TypeName.GetUniqueTypeInfo = function (type) {
        var key = "__TsName";
        var keyValue = type[key];
        if (keyValue) {
            if (keyValue.type !== type) {
                type[key] = TypeName.NewTypeInfo(type);
                return type[key];
            }
            else {
                return keyValue;
            }
        }
        type[key] = TypeName.NewTypeInfo(type);
        return type[key];
    };
    TypeName.UpdateTypeInfo = function (type) {
        var info = TypeName.GetUniqueTypeInfo(type);
        var className = TypeName.GetClassName(type);
        info.className = className;
        info.name = className || info.temporalName;
        return info;
    };
    TypeName.NewTypeInfo = function (type) {
        var className = TypeName.GetClassName(type);
        var temporalName = Guid.NewGuid();
        return {
            type: type,
            temporalName: temporalName,
            className: className,
            typeName: type.name,
            name: className || temporalName
        };
    };
    TypeName.GetClassName = function (type) {
        var className = null;
        var classNameType = type["ClassNameType"];
        if (classNameType === type) {
            className = type["ClassName"];
        }
        return className;
    };
    TypeName.GetUniqueTypeName = function (type) {
        return TypeName.GetUniqueTypeInfo(type).temporalName;
    };
    return TypeName;
}());

var Collection = /** @class */ (function () {
    function Collection() {
        var _this = this;
        var initialItems = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            initialItems[_i] = arguments[_i];
        }
        Array.prototype.push.apply(this, initialItems);
        return new Proxy(this, {
            get: function (obj, key) {
                var keyType = typeof (key);
                if (keyType === "number" || (keyType === 'string' && (Number.isInteger(Number(key))))) {
                    var result = _this.$get$(keyType === "number" ? key : parseInt(key));
                    if (result !== Collection._noReturn) {
                        return result;
                    }
                }
                return obj[key];
            },
            set: function (obj, key, value) {
                var keyType = typeof (key);
                if (keyType === "number" || (keyType === 'string' && (Number.isInteger(Number(key))))) {
                    var result = _this.$set$(keyType === "number" ? key : parseInt(key), value);
                    if (result === Collection._noReturn) {
                        obj[key] = value;
                    }
                }
                else {
                    obj[key] = value;
                }
                return true;
            }
        });
    }
    Collection.prototype.$get$ = function (index) {
        return Collection._noReturn;
    };
    Collection.prototype.$set$ = function (index, value) {
        return Collection._noReturn;
    };
    Collection._noReturn = {};
    return Collection;
}());
Object.setPrototypeOf(Collection.prototype, Array.prototype);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

var StackTracePoint = /** @class */ (function () {
    function StackTracePoint() {
        this.IsExternal = false;
        this.TotalTime = 0;
        this.CallCount = 0;
        this.Children = {};
    }
    return StackTracePoint;
}());
var Profiling = /** @class */ (function () {
    function Profiling() {
    }
    Profiling.Record = function (isExternal, className, methodName, action) {
        if (!Profiling.Enabled) {
            return action();
        }
        var key = className + "." + methodName;
        if (Profiling.StackPoint == null) {
            Profiling.StackPoint = Profiling.Log[key];
            if (!Profiling.StackPoint) {
                Profiling.StackPoint = new StackTracePoint();
                Profiling.StackPoint.ClassName = className;
                Profiling.StackPoint.IsExternal = isExternal;
                Profiling.StackPoint.MethodName = methodName;
                Profiling.StackPoint.Key = key;
                Profiling.StackPoint.Path = key;
                Profiling.Log[key] = Profiling.StackPoint;
            }
        }
        else {
            var point = Profiling.StackPoint.Children[key];
            if (!point) {
                point = new StackTracePoint();
                point.ClassName = className;
                point.MethodName = methodName;
                point.IsExternal = isExternal;
                point.ParentPath = Profiling.StackPoint.Path;
                point.Key = key;
                point.Path = point.ParentPath + " > " + point.Key;
                Profiling.StackPoint.Children[key] = point;
            }
            Profiling.StackPoint = point;
        }
        Profiling.Lookup[Profiling.StackPoint.Path] = Profiling.StackPoint;
        var startTime = new Date();
        var result = action();
        Profiling.RecordResult(Profiling.StackPoint, startTime);
        Profiling.StackPoint = Profiling.Lookup[Profiling.StackPoint.ParentPath];
        return result;
    };
    Profiling.RecordAsync = function (isExternal, className, methodName, action) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Profiling.Record(isExternal, className, methodName, action)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Profiling.RecordResult = function (stackPoint, startTime) {
        var endTime = new Date();
        var milliseconds = endTime.getTime() - startTime.getTime(); //Math.abs((startTime.getTime() - endTime.getTime()) / 1000);
        stackPoint.CallCount++;
        stackPoint.TotalTime += milliseconds;
        var flat = Profiling.LogFlat[stackPoint.Key];
        if (!flat) {
            flat = new StackTracePoint();
            flat.IsExternal = stackPoint.IsExternal;
            flat.ClassName = stackPoint.ClassName;
            flat.MethodName = stackPoint.MethodName;
            flat.Key = stackPoint.Key;
            flat.CallCount = stackPoint.CallCount;
            flat.TotalTime = stackPoint.TotalTime;
            Profiling.LogFlat[stackPoint.Key] = flat;
        }
        else {
            flat.CallCount++;
            flat.TotalTime += milliseconds;
        }
    };
    Profiling.Enabled = true;
    Profiling.Log = {};
    Profiling.LogFlat = {};
    Profiling.Lookup = {};
    Profiling.StackTrace = new Array();
    Profiling.StackPoint = null;
    return Profiling;
}());

var TypeOf = /** @class */ (function () {
    function TypeOf() {
    }
    TypeOf.IsInstanceOfType = function (obj, type) {
        if (obj == null || type == null) {
            return false;
        }
        if (type instanceof TypeContainer) {
            type = type.type;
        }
        return obj instanceof type || (obj.constructor.prototype === type.constructor.prototype && obj.constructor.prototype.name !== "");
    };
    TypeOf.IsInstanceOf = function (obj, name) {
        if (obj === null || obj === undefined) {
            return false;
        }
        var objType = obj.constructor;
        while (true) {
            if (objType === Object || !objType) {
                break;
            }
            if (objType && typeof objType.InterfacesImplemented === "function") {
                var arr = objType.InterfacesImplemented();
                if (arr && arr.constructor === Array) {
                    for (var i = 0; i < arr.length; i++) {
                        if (arr[i] === name) {
                            return true;
                        }
                    }
                }
            }
            objType = Object.getPrototypeOf(objType);
        }
        return false;
    };
    TypeOf.Interface = function (name) {
        var inter = TypeOf.interfaceLookup[name];
        if (inter) {
            return inter;
        }
        inter = new Interface(name);
        TypeOf.interfaceLookup[name] = inter;
        return inter;
    };
    TypeOf.interfaceLookup = {};
    return TypeOf;
}());

//import { Type } from "./TypeDefinition";
var EnumValue = /** @class */ (function () {
    function EnumValue(Name, Value, EnumType) {
        this.Name = Name;
        this.Value = Value;
        this.EnumType = EnumType;
    }
    return EnumValue;
}());
var EnumValueCollection = /** @class */ (function (_super) {
    __extends(EnumValueCollection, _super);
    function EnumValueCollection(EnumType) {
        var _this = _super.call(this) || this;
        _this.EnumType = EnumType;
        TypeInfo.SetPrototypeOf(_this, EnumValueCollection.prototype);
        return _this;
    }
    EnumValueCollection.prototype.toString = function () {
        return Enum.ConvertToString(this.EnumType, this);
    };
    return EnumValueCollection;
}(Collection));
var Enum = /** @class */ (function (_super) {
    __extends(Enum, _super);
    function Enum(Values) {
        var _this = _super.call(this) || this;
        _this.Values = Values;
        TypeInfo.SetPrototypeOf(_this, Enum.prototype);
        return _this;
    }
    Object.defineProperty(Enum.prototype, "Entries", {
        get: function () {
            return this._Entries = this._Entries || this.ResolveEntries();
        },
        enumerable: true,
        configurable: true
    });
    Enum.Get = function (values) {
        if (!Enum._EnumMap.has(values)) {
            Enum._EnumMap.set(values, new Enum(values));
        }
        return Enum._EnumMap.get(values);
    };
    Enum.prototype.ResolveEntries = function () {
        return Enum.ResolveEnumEntries(this.Values);
    };
    Enum.ResolveEnumEntries = function (enumType) {
        if (enumType instanceof TypeContainer) {
            enumType = enumType.type;
        }
        if (enumType instanceof Enum) {
            enumType = enumType.Values;
        }
        var arr = new EnumValueCollection(enumType);
        for (var name_1 in enumType) {
            if (Object.prototype.hasOwnProperty.call(enumType, name_1)) {
                if (/^\d+$/.test(name_1)) {
                    arr.push(new EnumValue(enumType[name_1], +name_1, enumType));
                }
            }
        }
        return arr;
    };
    Object.defineProperty(Enum.prototype, "IsEnum", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Enum.prototype.ConvertToString = function (value) {
        if (this.HasFlags) {
            var values = this.GetEntries(value);
        }
        return this.Values[value];
    };
    Enum.ConvertToString = function (enumType, value) {
        if (enumType instanceof TypeContainer) {
            enumType = enumType.type;
        }
        var values = Enum.Flatten(enumType, value);
        var result = "";
        for (var i = 0; i < values.length; i++) {
            result += values[i].Name;
            if (i < values.length - 1) {
                result += ", ";
            }
        }
        return result;
    };
    Enum.prototype.ConvertFromString = function (value) {
        if (!Object.prototype.hasOwnProperty.call(this.Values, value)) {
            throw new Error("No such enum value");
        }
        return this.Values[value];
    };
    Enum.prototype.TryConvertFromString = function (value) {
        return this.Values[value];
    };
    Enum.GetName = function (type, value) {
        if (type instanceof TypeContainer) {
            type = type.type;
        }
        if (typeof type === "function" && typeof type["Values"] === "object") {
            type = type["Values"];
        }
        return type[value];
    };
    Enum.Parse = function (type, value) {
        if (type instanceof TypeContainer) {
            type = type.type;
        }
        if (type instanceof Enum) {
            return Enum.Parse(type.Values, value);
        }
        if (Enum.HasFlags(type)) {
            var values = value.split(",");
            var result_1 = 0;
            for (var i = 0; i < values.length; i++) {
                var name_2 = (values[i] || "").trim();
                if (name_2) {
                    result_1 |= type[name_2];
                }
            }
            return result_1;
        }
        var result = type[value];
        return result === undefined || result === null ? null : result;
    };
    Enum.SetHasFlags = function (enumType) {
        if (enumType instanceof TypeContainer) {
            enumType = enumType.type;
        }
        Object.defineProperty(enumType, "hasFlags", {
            value: true,
            writable: false,
            enumerable: false
        });
    };
    Object.defineProperty(Enum.prototype, "HasFlags", {
        get: function () {
            return this.Values["hasFlags"] === true;
        },
        enumerable: true,
        configurable: true
    });
    Enum.HasFlags = function (enumType) {
        if (enumType instanceof TypeContainer) {
            enumType = enumType.type;
        }
        if (enumType instanceof Enum) {
            return enumType.HasFlags;
        }
        return enumType.hasFlags === true;
    };
    Enum.prototype.HasFlag = function (values, flag) {
        return Enum.HasFlag(values, flag);
    };
    Enum.HasFlag = function (values, flag) {
        return (values & flag) === flag;
    };
    Enum.SetFlag = function (values, flag) {
        if (!Enum.HasFlag(values, flag)) {
            return values | flag;
        }
        return values;
    };
    Enum.RemoveFlag = function (values, flag) {
        if (Enum.HasFlag(values, flag)) {
            return values & ~flag;
        }
        return values;
    };
    // public GetEntries2<TValue extends T | number | EnumValue<any> | Array<TValue>>(
    //     value: TValue
    // ) {
    //     if (!Array.isArray(value) && !(typeof value === "number") && !(value instanceof EnumValue)) {
    //         return Enum.Flatten(this, <number><any>value);
    //     }
    //     let flattened = Enum.Flatten(this, value);
    // }
    Enum.prototype.GetEntries = function (value) {
        return Enum.GetEntries(this.Values, value);
    };
    Enum.ToObject = function (enumType, value) {
        return Enum.GetEntries(enumType, +value);
    }; //public static ToString(enumType: any, value: )
    Enum.Flatten = function (enumType, value) {
        if (enumType instanceof TypeContainer) {
            enumType = enumType.type;
        }
        var all = Enum.FlattenInternal(enumType, value, new EnumValueCollection(enumType));
        var final = new EnumValueCollection(enumType);
        var names = new Array();
        for (var i = 0; i < all.length; i++) {
            var entry = all[i];
            if (names.indexOf(entry.Name) === -1) {
                names.push(entry.Name);
                final.push(entry);
            }
        }
        return final;
    };
    Enum.FlattenInternal = function (enumType, value, result) {
        if (Array.isArray(value) || value instanceof Array) {
            for (var i = 0; i < value.length; i++) {
                Enum.FlattenInternal(enumType, value[i], result);
            }
        }
        else if (typeof value === "number") {
            var thisResult = Enum.GetEntries(enumType, value);
            for (var i = 0; i < thisResult.length; i++) {
                result.push(thisResult[i]);
            }
        }
        else if (value["constructor"] === EnumValue) {
            Enum.FlattenInternal(enumType, value.Value, result);
        }
        return result;
    };
    Enum.GetEntries = function (enumType, value) {
        if (enumType instanceof TypeContainer) {
            enumType = enumType.type;
        }
        var entries = Enum.ResolveEnumEntries(enumType);
        var hasFlags = Enum.HasFlags(enumType);
        var matches = new EnumValueCollection(enumType);
        for (var i = 0; i < entries.length; i++) {
            if (hasFlags) {
                if (Enum.HasFlag(value, entries[i].Value)) {
                    matches.push(entries[i]);
                }
            }
            else if (value === entries[i].Value) {
                matches.push(entries[i]);
            }
        }
        return matches;
    };
    Enum._EnumMap = new Map();
    return Enum;
}(Function));

var PropertyInfo = /** @class */ (function () {
    function PropertyInfo(name, declaringType, propertyTypeMetadata, isPublic, jsonSerializeIgnore) {
        if (declaringType === void 0) { declaringType = null; }
        if (propertyTypeMetadata === void 0) { propertyTypeMetadata = null; }
        if (isPublic === void 0) { isPublic = true; }
        if (jsonSerializeIgnore === void 0) { jsonSerializeIgnore = false; }
        this._propertyType = new TypeContainer(PropertyInfo);
        this.GenericTypeArguments = [];
        this.IsPublic = true;
        this.JsonSerializeIgnore = true;
        this.Name = name;
        this.DeclaringType = declaringType;
        this.PropertyTypeMetadata = propertyTypeMetadata;
        this.IsPublic = isPublic;
        this.JsonSerializeIgnore = jsonSerializeIgnore;
    }
    Object.defineProperty(PropertyInfo.prototype, "PropertyType", {
        get: function () {
            if (this.PropertyTypeMetadata == null) {
                return null;
            }
            if (this.PropertyTypeMetadata != null) {
                this._propertyType.nameOverride = this.PropertyTypeMetadata.Name;
                this._propertyType.isGeneric = this.PropertyTypeMetadata.IsGeneric;
            }
            return this._propertyType;
        },
        enumerable: true,
        configurable: true
    });
    PropertyInfo.prototype.GetValue = function (obj) {
        return obj[this.Name];
    };
    PropertyInfo.prototype.SetValue = function (obj, value) {
        return obj[this.Name] = value;
    };
    return PropertyInfo;
}());

var MethodInfo = /** @class */ (function () {
    function MethodInfo(name, declaringType) {
        this.Name = name;
        if (declaringType instanceof TypeContainer) {
            declaringType = declaringType.type;
        }
        this.DeclaringType = declaringType;
    }
    MethodInfo.prototype.Invoke = function (context) {
        var _a;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (context == null) {
            context = this.DeclaringType;
        }
        return (_a = context[this.Name]).apply.apply(_a, __spread([context], args));
    };
    return MethodInfo;
}());

var Enumerable = /** @class */ (function () {
    function Enumerable() {
    }
    Enumerable.prototype.Count = function (array, filter) {
        return Enumerable.Count(array, filter);
    };
    Enumerable.prototype.IndexOf = function (array, entity) {
        return Enumerable.IndexOf(array, entity);
    };
    Enumerable.prototype.ToList = function (array) {
        return Enumerable.ToList(array);
    };
    Enumerable.prototype.Any = function (array, filter) {
        return Enumerable.Any(array, filter);
    };
    Enumerable.prototype.All = function (array, filter) {
        return Enumerable.All(array, filter);
    };
    Enumerable.prototype.Where = function (array, filter) {
        return Enumerable.Where(array, filter);
    };
    Enumerable.prototype.Single = function (array, filter) {
        if (filter === void 0) { filter = null; }
        return Enumerable.Single(array, filter);
    };
    Enumerable.prototype.Skip = function (array, amount) {
        return Enumerable.Skip(array, amount);
    };
    Enumerable.prototype.Take = function (array, amount) {
        return Enumerable.Take(array, amount);
    };
    Enumerable.prototype.Select = function (array, filter) {
        if (filter === void 0) { filter = null; }
        return Enumerable.Select(array, filter);
    };
    Enumerable.prototype.SelectMany = function (array, selector) {
        if (selector === void 0) { selector = null; }
        return Enumerable.SelectMany(array, selector);
    };
    Enumerable.prototype.Distinct = function (array) {
        return Enumerable.Distinct(array);
    };
    Enumerable.prototype.OrderBy = function (array, orderFunc) {
        return Enumerable.OrderBy(array, orderFunc);
    };
    Enumerable.prototype.OrderByDescending = function (array, orderFunc) {
        return Enumerable.OrderByDescending(array, orderFunc);
    };
    Enumerable.ToList = function (array) {
        return Enumerable.EnsureIterable(array).slice(0);
    };
    Enumerable.OrderBy = function (array, orderFunc) {
        array = Enumerable.EnsureIterable(array);
        var length = Enumerable.GetLength(array);
        var temp = [];
        for (var i = 0; i < length; i++) {
            temp[i] = [array[i], i];
        }
        temp.sort(function (a, b) {
            var aVal = orderFunc(a[0]);
            var bVal = orderFunc(b[0]);
            if (aVal < bVal) {
                return -1;
            }
            if (aVal > bVal) {
                return 1;
            }
            return a[1] - b[1];
        });
        var copy = [];
        for (var i = 0; i < temp.length; i++) {
            copy[i] = temp[i][0];
        }
        return copy;
    };
    Enumerable.OrderByDescending = function (array, orderFunc) {
        array = Enumerable.EnsureIterable(array);
        var length = Enumerable.GetLength(array);
        var temp = [];
        for (var i = 0; i < length; i++) {
            temp[i] = [array[i], i];
        }
        temp.sort(function (a, b) {
            var aVal = orderFunc(a[0]);
            var bVal = orderFunc(b[0]);
            if (aVal < bVal) {
                return 1;
            }
            if (aVal > bVal) {
                return -1;
            }
            return a[1] - b[1];
        });
        var copy = [];
        for (var i = 0; i < temp.length; i++) {
            copy[i] = temp[i][0];
        }
        return copy;
    };
    Enumerable.IndexOf = function (array, entity) {
        array = Enumerable.EnsureIterable(array);
        var length = Enumerable.GetLength(array);
        for (var i = 0; i < length; i++) {
            if (array[i] == entity) {
                return i;
            }
        }
        return -1;
    };
    Enumerable.Distinct = function (array) {
        array = Enumerable.EnsureIterable(array);
        var length = Enumerable.GetLength(array);
        var arr = new Array();
        for (var i = 0; i < length; i++) {
            var item = array[i];
            if (!Enumerable.Contains(arr, item)) {
                arr.push(item);
            }
        }
        return arr;
    };
    Enumerable.Remove = function (array, entity) {
        var j = 0;
        var found = false;
        while (true) {
            var finished = true;
            for (var i = j; i < array.length; i++) {
                if (array[i] === entity) {
                    array.splice(i, 1);
                    j = i;
                    finished = false;
                    found = true;
                    break;
                }
            }
            if (finished) {
                break;
            }
        }
        return found;
    };
    Enumerable.Count = function (array, filter) {
        if (filter === void 0) { filter = null; }
        var result = Enumerable.IfWhere(array, filter);
        return result.length;
    };
    Enumerable.Sum = function (array, filter) {
        if (filter === void 0) { filter = null; }
        array = Enumerable.EnsureIterable(array);
        var length = Enumerable.GetLength(array);
        var total = 0;
        for (var i = 0; i < length; i++) {
            total += filter(array[i]);
        }
        return total;
    };
    Enumerable.Select = function (array, filter) {
        if (filter === void 0) { filter = null; }
        array = Enumerable.EnsureIterable(array);
        var length = Enumerable.GetLength(array);
        var result = new Array();
        for (var i = 0; i < length; i++) {
            result.push(filter(array[i]));
        }
        return result;
    };
    Enumerable.SelectMany = function (array, selector) {
        if (selector === void 0) { selector = null; }
        array = Enumerable.EnsureIterable(array);
        var length = Enumerable.GetLength(array);
        var result = new Array();
        for (var i = 0; i < length; i++) {
            result.push.apply(result, __spread(selector(array[i])));
        }
        return result;
    };
    Enumerable.Single = function (array, filter) {
        if (filter === void 0) { filter = null; }
        var result = Enumerable.IfWhere(array, filter);
        if (result.length > 1) {
            throw new Error("Too many results returned for Single() query.");
        }
        if (result.length < 1) {
            throw new Error("Too few results returned for Single() query.");
        }
        return result[0];
    };
    Enumerable.SingleOrDefault = function (array, filter) {
        if (filter === void 0) { filter = null; }
        array = Enumerable.IfWhere(array, filter);
        if (array.length < 1) {
            return null;
        }
        if (array.length > 1) {
            throw new Error("More than one entity returned for \"SingleOrDefault\" call");
        }
        return Enumerable.Single(array);
    };
    Enumerable.Skip = function (array, amount) {
        if (Array.isArray(array)) {
            return array.slice(amount);
        }
        array = Enumerable.EnsureIterable(array);
        var length = Enumerable.GetLength(array);
        var result = [];
        for (var i = amount; i < length; i++) {
            result.push(array[i]);
        }
        return result;
    };
    Enumerable.Take = function (array, amount) {
        if (Array.isArray(array)) {
            return array.slice(0, amount);
        }
        array = Enumerable.EnsureIterable(array);
        var result = [];
        var length = Enumerable.GetLength(array);
        for (var i = 0; i < amount && i < length; i++) {
            result.push(array[i]);
        }
        return result;
    };
    Enumerable.First = function (array, filter) {
        if (filter === void 0) { filter = null; }
        var result = Enumerable.IfWhere(array, filter);
        if (result.length < 1) {
            throw new Error("Too few results returned for First() query.");
        }
        return result[0];
    };
    Enumerable.FirstOrDefault = function (array, filter) {
        if (filter === void 0) { filter = null; }
        array = Enumerable.IfWhere(array, filter);
        if (array.length < 1) {
            return null;
        }
        return Enumerable.First(array);
    };
    Enumerable.Last = function (array, filter) {
        if (filter === void 0) { filter = null; }
        var result = Enumerable.IfWhere(array, filter);
        if (result.length < 1) {
            throw new Error("Too few results returned for Last() query.");
        }
        return result[result.length - 1];
    };
    Enumerable.LastOrDefault = function (array, filter) {
        if (filter === void 0) { filter = null; }
        array = Enumerable.IfWhere(array, filter);
        if (array.length < 1) {
            return null;
        }
        return Enumerable.Last(array);
    };
    Enumerable.IfWhere = function (array, filter) {
        if (filter === void 0) { filter = null; }
        if (filter) {
            return Enumerable.Where(array, filter);
        }
        return Enumerable.ToList(array);
    };
    Enumerable.EnsureIterable = function (array) {
        if (!Array.isArray(array)) {
            if (array instanceof Map) {
                return Array.from(array.entries());
            }
            if (array instanceof Collection) {
                return array.slice(0);
            }
            var copy = [];
            var length_1 = Enumerable.GetLength(array);
            for (var i = 0; i < length_1; i++) {
                copy.push(array[i]);
            }
            return copy;
        }
        return array;
    };
    Enumerable.GetLength = function (array) {
        var length = array["length"] || array["size"];
        return length;
    };
    Enumerable.Where = function (array, filter) {
        if (!filter) {
            return Enumerable.ToList(array);
        }
        if (Array.isArray(array)) {
            return array.filter(filter);
        }
        var filtered = [];
        array = Enumerable.EnsureIterable(array);
        var length = Enumerable.GetLength(array);
        for (var i = 0; i < length; i++) {
            if (filter(array[i])) {
                filtered.push(array[i]);
            }
        }
        return filtered;
    };
    Enumerable.Cast = function (array) {
        return Enumerable.ToList(array);
    };
    Enumerable.Any = function (array, filter) {
        if (filter === void 0) { filter = null; }
        if (!filter) {
            return Enumerable.GetLength(array) > 0;
        }
        return Enumerable.Where(array, filter).length > 0;
    };
    Enumerable.All = function (array, filter) {
        return Enumerable.Where(array, filter).length === Enumerable.GetLength(array);
    };
    Enumerable.Contains = function (array, entity) {
        return Enumerable.Any(array, function (t) { return t === entity; });
    };
    Enumerable.TypeContains = function (array, entity) {
        return Enumerable.Any(array, function (t) { return TypeInfo.ReferToSameType(t, entity); });
    };
    Enumerable.Concat = function (array1, array2) {
        return Enumerable.EnsureIterable(array1).concat(Enumerable.EnsureIterable(array2));
    };
    return Enumerable;
}());

var StringUtil = /** @class */ (function () {
    function StringUtil() {
    }
    StringUtil.CharCodeAt = function (codeOrString, index) {
        if (!codeOrString) {
            return null;
        }
        if (codeOrString["charCodeAt"] && typeof codeOrString["charCodeAt"] === "function") {
            return codeOrString["charCodeAt"](index);
        }
        if (typeof codeOrString === "string") {
            return codeOrString.charCodeAt(index);
        }
        return codeOrString[index];
    };
    StringUtil.EnsureChar = function (codeOrString) {
        if (typeof codeOrString === "string") {
            return codeOrString;
        }
        return String.fromCharCode(codeOrString);
    };
    StringUtil.SplitAndRemoveEmptyEntries = function (str, splitBy) {
        if (typeof splitBy === "number") {
            splitBy = String.fromCharCode(splitBy);
        }
        if (Array.isArray(splitBy)) {
            var strArray = new Array();
            for (var i_1 = 0; i_1 < splitBy.length; i_1++) {
                var v = splitBy[i_1];
                if (typeof v === "number") {
                    strArray.push(String.fromCharCode(v));
                }
                else {
                    strArray.push(v);
                }
            }
            var tempChar = strArray[0]; // We can use the first token as a temporary join character
            for (var i = 1; i < splitBy.length; i++) {
                str = str.split(strArray[i]).join(tempChar);
            }
            return str.split(tempChar);
        }
        var split = str.split(splitBy);
        return split.filter(function (_) { return !StringUtil.IsNullOrEmpty(_); });
    };
    StringUtil.Replace = function (str, search, replaceWith) {
        if (typeof search === "number") {
            search = String.fromCharCode(search);
        }
        if (typeof replaceWith === "number") {
            replaceWith = String.fromCharCode(replaceWith);
        }
        return str.split(search).join(replaceWith);
    };
    StringUtil.IsNullOrWhiteSpace = function (str) {
        return str === undefined || str === null || str.trim() === "";
    };
    StringUtil.IsNullOrEmpty = function (str) {
        return str === undefined || str === null || str === "";
    };
    StringUtil.TrimStart = function (input, find) {
        var search = StringUtil.EnsureStringFromStringOrCharCode(find);
        while (input && input.length > 0 && input.indexOf(search) === 0) {
            input = input.substr(search.length);
        }
        return input;
    };
    StringUtil.TrimEnd = function (input, find) {
        var search = StringUtil.EnsureStringFromStringOrCharCode(find);
        while (input && input.length > 0 && input.length >= search.length && input.substring(input.length - search.length) === search) {
            input = input.substr(0, input.length - search.length);
        }
        return input;
    };
    StringUtil.EnsureStringFromStringOrCharCode = function (input) {
        if (typeof input == "number") {
            return String.fromCharCode(input);
        }
        return input;
    };
    StringUtil.Trim = function (input, find) {
        return StringUtil.TrimEnd(StringUtil.TrimStart(input, find), find);
    };
    StringUtil.IndexOf = function (source, searchString, comparison) {
        return source.indexOf(searchString);
    };
    StringUtil.ToCharArray = function (source) {
        var strings = source.split('');
        var chars = new Array();
        for (var i = 0; i < strings.length; i++) {
            chars.push(strings[i].charCodeAt(0));
        }
        return chars;
    };
    return StringUtil;
}());

var TypeMetadata = /** @class */ (function () {
    function TypeMetadata(name, isGeneric, genericTypeParameters) {
        if (genericTypeParameters === void 0) { genericTypeParameters = null; }
        this.IsGeneric = false;
        this.Name = name;
        this.IsGeneric = isGeneric;
        this.GenericTypeArguments = genericTypeParameters || [];
    }
    Object.defineProperty(TypeMetadata.prototype, "AccessorName", {
        get: function () {
            return this.Name + "Type";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeMetadata.prototype, "GenericTypeParameters", {
        get: function () {
            return this.GenericTypeArguments;
        },
        enumerable: true,
        configurable: true
    });
    TypeMetadata.Parse = function (fullName) {
        var type = new TypeMetadata(null, null);
        var isInBrackets = 0;
        var part = "";
        var genericParts = new Array();
        for (var i = 0; i < fullName.length; i++) {
            if (fullName.charCodeAt(i) == '<'.charCodeAt(0)) {
                if (isInBrackets == 0) {
                    type.Name = part;
                    part = "";
                    isInBrackets++;
                    continue;
                }
                isInBrackets++;
            }
            else if (fullName.charCodeAt(i) == '>'.charCodeAt(0)) {
                isInBrackets--;
                if (isInBrackets == 0) {
                    genericParts.push((part.trim()));
                    part = "";
                    continue;
                }
            }
            if (isInBrackets == 1 && fullName.charCodeAt(i) == ','.charCodeAt(0)) {
                genericParts.push((part.trim()));
                part = "";
                continue;
            }
            part += String.fromCharCode(fullName.charCodeAt(i));
        }
        if (part.length > 2 && part.indexOf("$") === 0 && part[part.length - 1] == "$") {
            part = part.substr(1, part.length - 2);
            type.IsGeneric = true;
        }
        if (!(StringUtil.IsNullOrWhiteSpace(part))) {
            type.Name = part;
        }
        var subTypes = new Array();
        for (var i = 0; i < genericParts.length; i++) {
            subTypes.push(TypeMetadata.Parse(genericParts[i]));
        }
        type.GenericTypeArguments = subTypes;
        return type;
    };
    return TypeMetadata;
}());

var TypeInfo = /** @class */ (function () {
    function TypeInfo() {
    }
    TypeInfo.IsDefined = function (type, attribute, inherit) {
        if (!attribute) {
            return false;
        }
        attribute = attribute.trim();
        if (attribute === "FlagsAttribute") {
            return Enum.HasFlags(type);
        }
        return false;
    };
    TypeInfo.SetPrototypeOf = function (O, proto) {
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(O, proto);
            return O;
        }
        var magic = '__proto__';
        if (typeof O !== 'object' || O === null) {
            throw new TypeError('can not set prototype on a non-object');
        }
        if (typeof proto !== 'object' && proto !== null) {
            throw new TypeError('can only set prototype to an object or null');
        }
        var set;
        try {
            // this works already in Firefox and Safari
            set = Object.getOwnPropertyDescriptor(Object.prototype, magic).set;
            set.call({}, null);
        }
        catch (o_O) {
            if (
            // IE < 11 cannot be shimmed
            Object.prototype !== {}[magic] ||
                // neither can any browser that actually
                // implemented __proto__ correctly
                // (all but old V8 will return here)
                {
                    __proto__: null
                }.__proto__ === void 0
            // this case means null objects cannot be passed
            // through setPrototypeOf in a reliable way
            // which means here a **Sham** is needed instead
            ) {
                for (var prop in proto) {
                    if (!O.hasOwnProperty(prop)) {
                        O[prop] = proto[prop];
                    }
                }
                return O;
            }
            // nodejs 0.8 and 0.10 are (buggy and..) fine here
            // probably Chrome or some old Mobile stock browser
            set =
                function (proto) {
                    O[magic] = proto;
                };
            // please note that this will **not** work
            // in those browsers that do not inherit
            // __proto__ by mistake from Object.prototype
            // in these cases we should probably throw an error
            // or at least be informed about the issue
            // (setPrototypeOf as any)["polyfill"] = setPrototypeOf(
            //     setPrototypeOf({}, null),
            //     Object.prototype
            // ) instanceof Object;
            // setPrototypeOf.polyfill === true means it works as meant
            // setPrototypeOf.polyfill === false means it's not 100% reliable
            // setPrototypeOf.polyfill === undefined
            // or
            // setPrototypeOf.polyfill ==  null means it's not a polyfill
            // which means it works as expected
            // we can even delete Object.prototype.__proto__;
        }
        set.call(O, proto);
        return O;
    };
    TypeInfo.BaseType = function (type) {
        if (!type) {
            return type;
        }
        if (type instanceof TypeContainer) {
            type = type.type;
        }
        var baseType = Object.getPrototypeOf(type);
        if (baseType && typeof baseType === "function") {
            var baseTypeString = baseType.toString();
            if (baseTypeString != null && baseTypeString.trim().split(" ").join("").startsWith("function(") && type.prototype) {
                // Fix for IE10
                baseType = Object.getPrototypeOf(type.prototype);
                if (baseType && baseType.constructor) {
                    baseType = baseType.constructor;
                }
            }
        }
        if (type === baseType) {
            return null;
        }
        return baseType;
    };
    TypeInfo.NameOf = function (type) {
        if (!type) {
            return null;
        }
        if (type instanceof TypeContainer) {
            return type.fullName;
        }
        if (type instanceof TypeMetadata) {
            return type.Name;
        }
        return TypeContainer.Get(type).uniqueName;
        // Delay instantiation of this to avoid circular dependency
        /*



        TypeInfo._nameOfLookup = TypeInfo._nameOfLookup || new Dictionary<any, any>();



        if (!TypeInfo._nameOfLookup.ContainsKey(type)) {



            TypeInfo._nameOfLookup.Set(type, {



                Name: TypeName.GetUniqueTypeName(type),



                Type: type



            });



        }



        return TypeInfo._nameOfLookup.Get(type).Name;



        */
    };
    TypeInfo.GetNameOf = function (type) {
        var ctor = typeof type === "function" ? type : type.constructor;
        var name = ctor.name;
        if (!name && typeof ctor === "function") {
            var result = ctor.toString().trim().match(/^function\s*([^\s(]+)/);
            name = result && result.length > 1 ? result[1] : "";
        } // if (!name) {
        //     throw new Error("Unable to get the name of type \"" + (type === null ? "null" : type.toString()) + "\".");
        // }
        if (name === "Interface" && type.Name) {
            return type.Name;
        }
        if (name === "Function") {
            return type.name;
        }
        return name;
    };
    TypeInfo.IsArray = function (obj) {
        return Array.isArray(obj) || obj instanceof Array;
        //var ctor = obj.constructor;
        //while (true) {
        //    if (ctor === Array) {
        //        return true;
        //    }
        //    // Fix for IE10
        //    if (ctor.constructor && ctor.constructor === Array.constructor) {
        //        return true;
        //    }
        //    ctor = Object.getPrototypeOf(ctor);
        //    if (ctor === Object || !ctor) {
        //        break;
        //    }
        //}
        //return false;
    };
    TypeInfo.IsClass = function (type) {
        var isClass = false;
        try {
            isClass = JSON.stringify(type) === "{}";
        }
        catch (e) { }
        return isClass;
    };
    TypeInfo.IsAssignableFrom = function (to, from) {
        if (from == null) {
            return false;
        }
        if (from instanceof TypeContainer) {
            from = from.type;
        }
        if (to instanceof TypeContainer) {
            to = to.type;
        }
        if (to instanceof Interface && to.Name === "IEnumerable") {
            if (from instanceof Interface && from.Name === "IEnumerable") {
                return true;
            }
            return TypeInfo.IsAssignableFrom(Array, from);
        }
        if (!from.IsAssignableFrom || from.IsAssignableFrom.Type !== from) {
            from.IsAssignableFrom = {
                Lookup: new Map(),
                Type: from
            };
        }
        var isAssignableFrom = from.IsAssignableFrom.Lookup.get(to);
        if (isAssignableFrom == null) {
            from.IsAssignableFrom.Lookup.set(to, TypeInfo.GetIsAssignableFrom(to, from));
        }
        return from.IsAssignableFrom.Lookup.get(to);
    };
    TypeInfo.GetIsAssignableFrom = function (to, from) {
        if (TypeInfo.ReferToSameType(to, from)) {
            return true;
        }
        if (from instanceof TypeContainer) {
            from = from.type;
        }
        if (to instanceof TypeContainer) {
            to = to.type;
        }
        var checkInterfaces = false;
        if (TypeOf.IsInstanceOfType(to, Interface)) {
            checkInterfaces = true;
        }
        if (typeof to !== "function" && to.constructor) {
            to = to.constructor;
        }
        if (typeof from !== "function" && from.constructor) {
            from = from.constructor;
            if (from === Object) {
                return false;
            }
        }
        if (checkInterfaces && typeof from.InterfacesImplemented === "function") {
            var interfacesImplemented = from.InterfacesImplemented();
            if (interfacesImplemented && interfacesImplemented.constructor === Array) {
                for (var i = 0; i < interfacesImplemented.length; i++) {
                    if (interfacesImplemented[i] === to.Name) {
                        return true;
                    }
                }
            }
        }
        if (to !== from) {
            return TypeInfo.IsAssignableFrom(to, TypeInfo.BaseType(from));
        }
        return true;
    };
    TypeInfo.GetType = function (input) {
        if (input === null || input === undefined) {
            return null;
        }
        var type = input.constructor;
        if (type === null || type === undefined) {
            return null;
        }
        type.RuntimePropertiesInput = input;
        if (!type.RuntimeProperties) {
            type.RuntimeProperties = function () {
                if (type !== Object && type.RuntimePropertiesArray) {
                    return type.RuntimePropertiesArray();
                }
                var currentInput = type.RuntimePropertiesInput;
                var lookup = new Map();
                var props = new Array();
                do {
                    props = props.concat(Object.getOwnPropertyNames(currentInput));
                    if (currentInput.constructor === Object) {
                        break;
                    }
                } while (currentInput = Object.getPrototypeOf(currentInput));
                for (var i = 0; i < props.length; i++) {
                    var prop = props[i];
                    if (!lookup.has(prop)) {
                        lookup.set(prop, new PropertyInfo(prop, type));
                    }
                }
                type.RuntimePropertiesArray = function () { return lookup; };
                input.RuntimeProperties = function () { return lookup; };
                return lookup;
            };
        }
        var genericTypeParameters = type["GenericTypeParameters"];
        var genericTypeParameterContainers = [];
        if (genericTypeParameters && Array.isArray(genericTypeParameters)) {
            for (var i = 0; i < genericTypeParameters.length; i++) {
                var p = genericTypeParameters[i];
                var value = input[p.AccessorName];
                if (!value) {
                    genericTypeParameterContainers = [];
                    break;
                }
                genericTypeParameterContainers.push(value);
            }
        }
        return TypeContainer.Get.apply(TypeContainer, __spread([type], genericTypeParameterContainers));
    };
    TypeInfo.ReferToSameType = function (leftType, rightType) {
        if ((!leftType && rightType) || (!rightType && leftType)) {
            return false;
        }
        if (!leftType && !rightType) {
            return true;
        }
        var leftName = leftType instanceof TypeContainer ? TypeContainer.GetUniqueTypeContainerName(leftType) : TypeName.GetUniqueTypeName(leftType);
        var rightName = rightType instanceof TypeContainer ? TypeContainer.GetUniqueTypeContainerName(rightType) : TypeName.GetUniqueTypeName(rightType);
        if (!leftName && !rightName) {
            return true;
        }
        if ((!leftName && rightName) || (!rightName && leftName)) {
            return false;
        }
        return leftName.toUpperCase() === rightName.toUpperCase();
    };
    TypeInfo.GetProperty = function (type, name) {
        return new PropertyInfo(name);
    };
    TypeInfo.GetRuntimeProperties = function (type) {
        //let originalType = type;
        if (type instanceof TypeContainer) {
            type = type.type;
        }
        if (typeof type !== "function" && type.constructor) {
            type = type.constructor;
        }
        // if (type[TypeInfo.__resolvedPropertiesKey]) {
        //     return type[TypeInfo.__resolvedPropertiesKey]();
        // }
        //if (type !== Object && type.GetRuntimePropertiesArray) {
        //    return type.GetRuntimePropertiesArray();
        //}
        var res = new Array();
        var dic = new Map();
        var sourceType = type;
        while (true) {
            if (type.PropertiesDeclared && typeof type.PropertiesDeclared === "function") {
                var members = type.PropertiesDeclared();
                if (members && members.constructor === Array) {
                    for (var i = 0; i < members.length; i++) {
                        var member = members[i];
                        if (!dic.has(member.Name)) {
                            dic.set(member.Name, member);
                        }
                    }
                }
            }
            if (type === Object) {
                break;
            }
            type = Object.getPrototypeOf(type);
            if (!type) {
                break;
            }
        }
        if (sourceType.RuntimeProperties && typeof sourceType.RuntimeProperties === "function") {
            var mapping = sourceType.RuntimeProperties();
            if (mapping && mapping.constructor === Map) {
                mapping.forEach(function (entryValue, key) {
                    if (!dic.has(entryValue.Name)) {
                        dic.set(entryValue.Name, entryValue);
                    }
                });
            }
        }
        dic.forEach(function (value, key) {
            res.push(value);
        });
        res = res.filter(function (p) { return p.IsPublic === true; });
        //if (originalType !== Object) {
        //    originalType.GetRuntimePropertiesArray = () => res.slice(0);
        //}
        // sourceType[TypeInfo.__resolvedPropertiesKey] = () => res.slice(0);
        // return sourceType[TypeInfo.__resolvedPropertiesKey]();
        return res.slice(0);
    };
    TypeInfo.GetObjectProperties = function (obj) {
        var res = new Array();
        for (var property in obj) {
            if (obj.hasOwnProperty(property)) {
                res.push(new PropertyInfo(property));
            }
        }
        return res;
    };
    TypeInfo.GetProperties = function (type) {
        type = TypeContainer.Get(type);
        var properties = new Array();
        if (type instanceof TypeContainer) {
            type = type.type;
        }
        while (type !== Object) {
            if (type instanceof TypeContainer) {
                type = type.type;
            }
            if (type.PropertiesDeclared && typeof type.PropertiesDeclared === "function") {
                properties.push.apply(properties, __spread(type.PropertiesDeclared().filter(function (p) { return p.Name.indexOf(".") === -1; })));
                type = TypeInfo.BaseType(type);
            }
        }
        return properties;
    };
    TypeInfo.GetMethod = function (type, name) {
        return new MethodInfo(name, type);
    };
    TypeInfo.GetMethods = function (type) {
        return new Array();
    };
    TypeInfo.GetRuntimeProperty = function (type, name) {
        TypeInfo._propertyMap = TypeInfo._propertyMap || new Map();
        if (!TypeInfo._propertyMap.has(type)) {
            var dic = new Map();
            var typeContainer = TypeContainer.Get(type);
            if (typeContainer.type["PropertiesDeclared"] && typeof typeContainer.type["PropertiesDeclared"] === "function") {
                var properties = TypeInfo.GetProperties(typeContainer);
                for (var i = 0; i < properties.length; i++) {
                    dic.set(properties[i].Name, properties[i]);
                }
                TypeInfo._propertyMap.set(type, dic);
            }
            else {
                TypeInfo._propertyMap.set(type, null);
            }
        }
        var lookup = TypeInfo._propertyMap.get(type);
        if (lookup == null) {
            return new PropertyInfo(name);
        }
        return lookup.get(name);
    };
    TypeInfo.GetRuntimeMethod = function (type, name) {
        return Enumerable.SingleOrDefault(TypeInfo.GetRuntimeMethods(type).filter(function (m) { return m.Name === name; }));
    };
    TypeInfo.GetRuntimeMethods = function (type) {
        if (type instanceof TypeContainer) {
            type = type.type;
        }
        if (typeof type !== "function" && type.constructor) {
            type = type.constructor;
        }
        var res = new Array();
        while (true) {
            if (type.FunctionsDeclared && typeof type.FunctionsDeclared === "function") {
                var members = type.FunctionsDeclared();
                if (members && members.constructor === Array) {
                    for (var i = 0; i < members.length; i++) {
                        res.push(new MethodInfo(members[i], type));
                    }
                }
            }
            type = Object.getPrototypeOf(type);
            if (!type || type === Object) {
                break;
            }
        }
        return res;
    };
    TypeInfo.__resolvedPropertiesKey = "__resolvedProperties";
    return TypeInfo;
}());

var Interface = /** @class */ (function (_super) {
    __extends(Interface, _super);
    function Interface(Name) {
        var _this = _super.call(this) || this;
        _this.Name = Name;
        TypeInfo.SetPrototypeOf(_this, Interface.prototype);
        return _this;
    }
    Object.defineProperty(Interface.prototype, "name", {
        get: function () {
            return this.Name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Interface.prototype, "IsEnum", {
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Interface.prototype.IsAssignableFrom = function (type) {
        return false;
    };
    return Interface;
}(Function));

var TypeContainer = /** @class */ (function () {
    function TypeContainer(type) {
        var genericTypeContainers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            genericTypeContainers[_i - 1] = arguments[_i];
        }
        this.isGeneric = false;
        this.nameOverride = null;
        this._uniqueName = null;
        this._genericTypes = genericTypeContainers;
        this._type = type;
    }
    Object.defineProperty(TypeContainer.prototype, "IsEnum", {
        get: function () {
            return this.type["IsEnum"] === true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeContainer.prototype, "IsArray", {
        get: function () {
            return this.type === Array || (this.type instanceof Interface && this.type.Name == "IEnumerable");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeContainer.prototype, "ClassName", {
        get: function () {
            return this.type["ClassName"];
        },
        set: function (value) {
            var old = this.type["ClassName"];
            this.type["ClassName"] = value;
            this.type["ClassNameType"] = this.type;
            if (old != value) {
                this._uniqueName = null;
                TypeName.UpdateTypeInfo(this.type);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeContainer.prototype, "genericTypes", {
        get: function () {
            return this._genericTypes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeContainer.prototype, "genericTypeParameters", {
        get: function () {
            var parameters = this.type["GenericTypeParameters"];
            if (parameters && parameters.length > 0) {
                return parameters;
            }
            return [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeContainer.prototype, "type", {
        get: function () {
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeContainer.prototype, "uniqueName", {
        get: function () {
            if (!this._uniqueName) {
                this._uniqueName = TypeName.GetUniqueTypeName(this.type);
            }
            return this._uniqueName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeContainer.prototype, "fullUniqueName", {
        get: function () {
            var thisName = this.uniqueName;
            if (this.genericTypes && this.genericTypes.length) {
                thisName = thisName + "<" + this.genericTypes.map(function (_) { return _.uniqueName; }).join(", ") + ">";
            }
            return thisName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeContainer.prototype, "fullName", {
        get: function () {
            var thisName = this.nameOverride || TypeName.GetUniqueTypeInfo(this.type).name;
            if (this.genericTypes && this.genericTypes.length) {
                thisName = thisName + "<" + this.genericTypes.map(function (_) { return _.fullName; }).join(", ") + ">";
            }
            return thisName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeContainer.prototype, "fullRawName", {
        get: function () {
            var thisName = this.nameOverride || this.type.name;
            if (this.genericTypes && this.genericTypes.length) {
                thisName = thisName + "<" + this.genericTypes.map(function (_) { return _.fullRawName; }).join(", ") + ">";
            }
            return thisName;
        },
        enumerable: true,
        configurable: true
    });
    TypeContainer.prototype.MakeGenericType = function () {
        var genericTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            genericTypes[_i] = arguments[_i];
        }
        return TypeContainer.Get.apply(TypeContainer, __spread([this.type], genericTypes));
    };
    TypeContainer.GetUniqueName = function (type) {
        var genericTypeContainers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            genericTypeContainers[_i - 1] = arguments[_i];
        }
        var uniqueId = "";
        if (type instanceof TypeContainer) {
            uniqueId = TypeContainer.GetUniqueTypeContainerName(type);
        }
        else {
            if (typeof type !== "function") {
                type = type.constructor;
            }
            uniqueId = TypeName.GetUniqueTypeName(type);
        }
        if (genericTypeContainers && genericTypeContainers.length) {
            uniqueId = uniqueId + "<" + genericTypeContainers.map(function (_) { return TypeContainer.GetUniqueTypeContainerName(_); }).join(",") + ">";
        }
        return uniqueId;
    };
    TypeContainer.GetUniqueTypeContainerName = function (type) {
        if (type instanceof Interface) {
            return type.Name;
        }
        var genericTypes = type.genericTypes;
        return TypeContainer.GetUniqueName.apply(TypeContainer, __spread([type.type], genericTypes));
    };
    TypeContainer.Get = function (type) {
        var genericTypeContainers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            genericTypeContainers[_i - 1] = arguments[_i];
        }
        if (!type) {
            return null;
        }
        if (type instanceof TypeContainer) {
            return type;
        }
        if (typeof type !== "function") {
            type = type.constructor;
        }
        var genericTypeContainersEnsured = new Array();
        for (var i = 0; i < genericTypeContainers.length; i++) {
            var t = genericTypeContainers[i];
            if (t instanceof TypeContainer) {
                genericTypeContainersEnsured.push(t);
            }
            else {
                var arg = genericTypeContainers[i];
                if (Array.isArray(arg)) {
                    genericTypeContainersEnsured.push(TypeContainer.Get.apply(TypeContainer, __spread([arg[0]], arg.splice(0, 1))));
                }
                else {
                    genericTypeContainersEnsured.push(TypeContainer.Get(arg));
                }
            }
        }
        var uniqueId = TypeContainer.GetUniqueName.apply(TypeContainer, __spread([type], genericTypeContainersEnsured));
        TypeContainer._lookup = TypeContainer._lookup || new Map();
        if (TypeContainer._lookup.has(uniqueId)) {
            return TypeContainer._lookup.get(uniqueId);
        }
        var container = new (TypeContainer.bind.apply(TypeContainer, __spread([void 0, type], genericTypeContainersEnsured)))();
        TypeContainer._lookup.set(uniqueId, container);
        return container;
    };
    return TypeContainer;
}());

var Serialization = /** @class */ (function () {
    function Serialization() {
    }
    Serialization.PrepareForJson = function (obj, type) {
        var typeAny = type;
        var properties = new Array();
        var baseType = typeAny;
        var useDeclaredProperties = false;
        while (baseType && baseType.PropertiesDeclared && typeof baseType.PropertiesDeclared === "function") {
            useDeclaredProperties = true;
            var thisProperties = baseType.PropertiesDeclared();
            for (var i = 0; i < thisProperties.length; i++) {
                var property = thisProperties[i];
                if (!property.IsPublic || property.JsonSerializeIgnore) {
                    continue;
                }
                var key = property.Name;
                if (properties.indexOf(key) === -1) {
                    properties.push(key);
                }
            }
            baseType = TypeInfo.BaseType(baseType);
        }
        if (useDeclaredProperties) {
            var data = {};
            for (var i = 0; i < properties.length; i++) {
                var key = properties[i];
                data[key] = obj[key];
            }
            return data;
        }
        return obj;
    };
    return Serialization;
}());

var DateUtil = /** @class */ (function () {
    function DateUtil() {
    }
    Object.defineProperty(DateUtil, "Empty", {
        get: function () {
            return new Date("0001-01-01T00:00:00.0+00:00");
        },
        enumerable: true,
        configurable: true
    });
    return DateUtil;
}());

//TsExportIdentifier:Enumerable
var DateTime = /** @class */ (function () {
    function DateTime() {
    }
    DateTime.AddDays = function (date, days) {
        return new Date(date.getDate() + days);
    };
    DateTime.AddHours = function (date, hours) {
        return new Date(date.getTime() + (hours * 60 * 60 * 1000));
    };
    DateTime.AddMinutes = function (date, minutes) {
        return new Date(date.getTime() + (minutes * 60 * 1000));
    };
    DateTime.AddSeconds = function (date, seconds) {
        return new Date(date.getTime() + (seconds * 1000));
    };
    DateTime.AddMilliseconds = function (date, milliseconds) {
        return new Date(date.getTime() + milliseconds);
    };
    return DateTime;
}());

var Nullable = /** @class */ (function () {
    function Nullable() {
    }
    Nullable.GetUnderlyingType = function (type) {
        return type;
    };
    return Nullable;
}());

var ExpressionExtensions = /** @class */ (function () {
    function ExpressionExtensions() {
    }
    ExpressionExtensions.GetValue = function (expression) {
        return expression.GetValue({});
    };
    return ExpressionExtensions;
}());

var BreakException = /** @class */ (function () {
    function BreakException(Return) {
        if (Return === void 0) { Return = undefined; }
        this.Return = Return;
    }
    return BreakException;
}());

var ObjectNullifier = /** @class */ (function () {
    function ObjectNullifier() {
    }
    ObjectNullifier.ClearProperty = function (entity, property) {
        delete entity[property];
        entity[property] = undefined;
    };
    return ObjectNullifier;
}());

var StringBuilder = /** @class */ (function () {
    function StringBuilder(currentString) {
        var _this = this;
        if (currentString === void 0) { currentString = null; }
        this._str = "";
        this.toString = function () {
            return _this._str;
        };
        this._str = currentString || "";
    }
    StringBuilder.prototype.AppendLine = function (line) {
        if (line === void 0) { line = ""; }
        this._str += line + "\n";
        return this;
    };
    StringBuilder.prototype.Append = function (text) {
        if (typeof text === "number") {
            this._str += String.fromCharCode(text);
        }
        else {
            this._str += text;
        }
        return this;
    };
    Object.defineProperty(StringBuilder.prototype, "Length", {
        get: function () {
            return this._str.length;
        },
        enumerable: true,
        configurable: true
    });
    StringBuilder.prototype.charCodeAt = function (index) {
        return this._str.charCodeAt(index);
    };
    StringBuilder.prototype.Remove = function (startIndex, length) {
        var left = this._str.substr(0, startIndex);
        var right = this._str.substr(startIndex + length);
        this._str = left + right;
        return this;
    };
    return StringBuilder;
}());

var Activator = /** @class */ (function () {
    function Activator() {
    }
    Activator.CreateInstance = function (type) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (type instanceof TypeContainer) {
            type = type.type;
        }
        return Activator.applyConstruct(type, args);
    };
    Activator.applyConstruct = function (ctor, params) {
        if (params && params.length === 1 && params[0] != null && params[0].constructor === Array) {
            params = params[0];
        }
        if (ctor.constructor && ctor.constructor === Array) {
            return [];
        }
        var obj;
        // Create the object with the desired prototype
        if (typeof ctor === "function" && /^\s*class\s+/.test(ctor.toString())) {
            // ES6
            obj = eval("new ctor(...params)");
            return obj;
        }
        if (typeof Object.create === "function") {
            // ECMAScript 5
            obj = Object.create(ctor.prototype);
        }
        else {
            // Fallback
            obj = makeObjectWithFakeCtor();
        }
        // Set the object's constructor
        obj.constructor = ctor;
        // Apply the constructor function
        var newobj = ctor.apply(obj, params);
        // If a constructor function returns an object, that
        // becomes the return value of `new`, so we handle
        // that here.
        if (typeof newobj === "object" || ctor.name === "Number" || ctor.name === "String" || ctor.name === "Date") {
            obj = newobj;
        }
        // Done!
        return obj;
        // Subroutine for building objects with specific prototypes
        function makeObjectWithFakeCtor() {
            function fakeCtor() { }
            fakeCtor.prototype = ctor.prototype;
            return new fakeCtor();
        }
    };
    return Activator;
}());

var DeepCloner = /** @class */ (function () {
    function DeepCloner() {
    }
    DeepCloner.Clone = function (obj, type) {
        var cache = new Array();
        var json = JSON.stringify(obj, function (key, value) {
            if (typeof value === "object" && value !== null) {
                var index = cache.indexOf(value);
                if (index !== -1) {
                    // Circular reference, create a reference object
                    var refObj = {};
                    refObj[DeepCloner.GuidProperty] = DeepCloner.Guid;
                    refObj[DeepCloner.ReferenceToProperty] = index;
                    return refObj;
                } // Store identity of this reference
                cache.push(value);
                index = cache.indexOf(value);
                value[DeepCloner.ReferenceProperty] = index;
                value[DeepCloner.GuidProperty] = DeepCloner.Guid;
            }
            return value;
        }); // Clean up the original's properties
        for (var i = 0; i < cache.length; i++) {
            delete cache[i][DeepCloner.ReferenceProperty];
            delete cache[i][DeepCloner.GuidProperty];
        }
        cache = null; // Enable garbage collection
        var cloned = JSON.parse(json);
        cache = [];
        var iterate = function (obj) {
            if (obj[DeepCloner.GuidProperty] === DeepCloner.Guid && obj[DeepCloner.ReferenceProperty] >= 0) {
                cache[obj[DeepCloner.ReferenceProperty]] = obj;
                obj[DeepCloner.ReferenceProperty] = undefined;
                obj[DeepCloner.GuidProperty] = undefined;
                delete obj[DeepCloner.ReferenceProperty];
                delete obj[DeepCloner.GuidProperty];
            }
            for (var property in obj) {
                if (obj.hasOwnProperty(property)) {
                    if (typeof obj[property] == "object" && obj[property] != null) {
                        if (obj[property][DeepCloner.GuidProperty] === DeepCloner.Guid && obj[property][DeepCloner.ReferenceToProperty] >= 0) {
                            var ref = cache[obj[property][DeepCloner.ReferenceToProperty]];
                            obj[property] = ref;
                        }
                        else {
                            iterate(obj[property]);
                        }
                    }
                }
            }
        };
        iterate(cloned);
        return cloned;
    };
    DeepCloner.ReferenceToProperty = "__referenceTo";
    DeepCloner.ReferenceProperty = "__reference";
    DeepCloner.GuidProperty = "__guid";
    DeepCloner.Guid = "3e718dd6-f063-4cb8-b9ed-c241e7027902";
    return DeepCloner;
}());

function Coalesce(left, right) {
    return left === null || left === undefined ? right() : left;
}

var queue = new Array();
function __defer(fn) {
    queue.push(fn);
    return null;
}
function __deferred() {
    queue.forEach(function (element) {
        element();
    });
}

var KeyValuePair = /** @class */ (function () {
    function KeyValuePair(key, value) {
        this.Key = key;
        this.Value = value;
    }
    return KeyValuePair;
}());

var TryGetValueResult = /** @class */ (function () {
    function TryGetValueResult() {
    }
    return TryGetValueResult;
}());
var DictionaryUtil = /** @class */ (function () {
    function DictionaryUtil() {
    }
    DictionaryUtil.GetKey = function (key, dictionaryKey) {
        if (key == null) {
            return null;
        }
        if (key instanceof TypeContainer) {
            key = key.type;
        }
        var type = typeof (key);
        switch (type) {
            case "number":
                return "tsutility_dictionary_key_number_" + key;
            case "string":
                // Prefix the key to avoid conflicts with the likes of "toString" etc.
                return "tsutility_dictionary_key_string_" + key;
            case "function":
                return TypeName.GetUniqueTypeName(key);
            case "object":
                {
                    var obj = key;
                    //let k = null;
                    // if(!obj.hasOwnProperty("___dic")){
                    //     //k = DictionaryUtil._objectCount++ + "";
                    //     //obj.___dic = k;
                    // }else{
                    //     k = obj.___dic;
                    // }
                    var k_1 = obj.___dic;
                    if (k_1 === undefined) {
                        k_1 = DictionaryUtil._objectCount++ + "";
                        obj.___dic =
                            function () {
                                return k_1;
                            };
                    }
                    else {
                        k_1 = k_1();
                    }
                    return k_1;
                    // let objectKeyProperty = dictionaryKey + "_obj_key";
                    // let indexer = key[objectKeyProperty];
                    // if (!indexer) {
                    //     let objectProperty = dictionaryKey + "_obj";
                    //     indexer = new DictionaryKey(true, "obj_" + DictionaryUtil._objectCount++);
                    //     key[objectKeyProperty] = indexer;
                    // }
                    // return indexer;
                }
            //return new DictionaryKey(false, dictionaryKey);
        }
        return null;
    };
    DictionaryUtil._objectCount = 0;
    return DictionaryUtil;
}());
var DictionaryItem = /** @class */ (function (_super) {
    __extends(DictionaryItem, _super);
    function DictionaryItem(key, value, Index, LookupKey) {
        var _this = _super.call(this, key, value) || this;
        _this.Index = Index;
        _this.LookupKey = LookupKey;
        _this.Deleted = false;
        return _this;
    }
    return DictionaryItem;
}(KeyValuePair));
var Dictionary = /** @class */ (function (_super) {
    __extends(Dictionary, _super);
    function Dictionary() {
        var _this = _super.call(this) || this;
        _this._internal = {};
        _this._internalByIndex = {};
        _this._keys = null;
        _this._values = null;
        TypeInfo.SetPrototypeOf(_this, Dictionary.prototype);
        _this._key = "dic_" + Dictionary._count++; //Guid.NewGuid().replace(new RegExp("-", 'g'), "_");
        return _this;
    }
    Dictionary.prototype.Keys = function () {
        if (!this._keys) {
            var arr = new Array();
            for (var i = 0; i < this.length; i++) {
                arr.push(this[i].Key);
            }
            this._keys = arr;
        }
        return this._keys;
    };
    Dictionary.prototype.Values = function () {
        if (!this._values) {
            var arr = new Array();
            for (var i = 0; i < this.length; i++) {
                arr.push(this[i].Value);
            }
            this._values = arr;
        }
        return this._values;
    };
    Dictionary.prototype.Clear = function () {
        var copy = this.slice();
        for (var i = 0; i < copy.length; i++) {
            this.Remove(copy[i].Key);
        }
        this.length = 0;
    };
    Dictionary.prototype.ContainsKey = function (key) {
        return this.GetItem(DictionaryUtil.GetKey(key, this._key)) != null;
    };
    Dictionary.prototype.TryGetValue = function (key, result) {
        var item = this.GetItem(DictionaryUtil.GetKey(key, this._key));
        if (item != null) {
            result(item.Value);
            return true;
        }
        return false;
    };
    Dictionary.prototype.TryGetValue2 = function (key, result) {
        var item = this.GetItem(DictionaryUtil.GetKey(key, this._key));
        if (item != null) {
            result.Value = item.Value;
            return true;
        }
        return false;
    };
    Dictionary.prototype.Get = function (key) {
        var item = this.GetItem(DictionaryUtil.GetKey(key, this._key));
        return item == null || item.Deleted ? null : item.Value;
    };
    Dictionary.prototype.GetItem = function (key) {
        var item = this._internal[key];
        if (!item || item.Deleted) {
            return undefined;
        }
        return item;
    };
    Dictionary.prototype.Set = function (key, value) {
        var lookupKey = DictionaryUtil.GetKey(key, this._key);
        var item = this.GetItem(lookupKey);
        if (item) {
            item.Value = value;
        }
        else {
            var kvp = new DictionaryItem(key, value, this.length, lookupKey);
            this._internal[lookupKey] = kvp;
            this[this.length++] = kvp;
            this._keys = null;
            this._values = null;
        }
    };
    Dictionary.prototype.Remove = function (key) {
        var item = this.GetItem(DictionaryUtil.GetKey(key, this._key));
        if (item) {
            this.RemoveItem(item);
            return true;
        }
        return false;
    };
    Dictionary.prototype.RemoveItem = function (item) {
        // if (item.LookupKey.CanBeIndexed) {
        //     delete this._internal[item.LookupKey.Key];
        // }
        // else {
        //     //delete item.Key[item.LookupKey.Key];
        //     // Object.defineProperty(item.Key, item.LookupKey.Key, {
        //     //     value: undefined,
        //     //     enumerable: false
        //     // });
        // }
        item.Deleted = true;
        var itemIndex = item.Index;
        if (this.length > 1) {
            this[itemIndex] = this[this.length - 1];
            this[itemIndex].Index = itemIndex;
        }
        delete this[this.length - 1];
        //delete this._internal[item.LookupKey];
        if (this._keys) {
            if (this.length > 1) {
                this._keys[itemIndex] = this._keys[this.length - 1];
            }
            delete this._keys[this.length - 1];
            if (this._keys.length > 0) {
                this._keys.length--;
            }
        }
        if (this._values) {
            if (this.length > 1) {
                this._values[itemIndex] = this._values[this.length - 1];
            }
            delete this._values[this.length - 1];
            if (this._values.length > 0) {
                this._values.length--;
            }
        }
        if (this.length > 0) {
            this.length--;
        }
    };
    Dictionary._count = 0;
    return Dictionary;
}(Collection));

var EqualityComparer = /** @class */ (function () {
    function EqualityComparer() {
    }
    EqualityComparer.CompareTo = function (left, right) {
        return left < right ? -1 : left > right ? 1 : 0;
    };
    EqualityComparer.Equals = function (left, right) {
        if (left === undefined) {
            left = null;
        }
        if (right === undefined) {
            right = null;
        }
        if (left instanceof Date && right instanceof Date) {
            return left.toString() === right.toString();
        }
        return left === right;
    };
    return EqualityComparer;
}());

var Expression = /** @class */ (function () {
    function Expression() {
    }
    Expression.prototype.GetValue = function (context) {
        return this.Func.apply(context, [context]);
    };
    Expression.Add = function (left, right) {
        var exp = new AddExpression(left, right);
        return exp;
    };
    Expression.Constant = function (value) {
        var exp = new ConstantExpression(value);
        return exp;
    };
    Expression.Parameter = function (type, name) {
        return new ParameterExpression(type, name);
    };
    Expression.Assign = function (left, right) {
        return new AssignExpression(left, right);
    };
    Expression.Property = function (expression, propertyName) {
        return new PropertyExpression(expression, propertyName);
    };
    Expression.Lambda = function (body) {
        var parameterExpressions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            parameterExpressions[_i - 1] = arguments[_i];
        }
        var fn = Expression.GetLambdaString(body, parameterExpressions);
        var compiled = Expression.Compile(fn);
        return compiled;
        // let fn = function () {
        //     let ctx = {};
        //     for (let i = 0; i < parameterExpressions.length; i++) {
        //         ctx[parameterExpressions[i].Name] = arguments[i];
        //     }
        //     return body.Func.apply(ctx, [ctx]);
        // };
        // return fn;
    };
    Expression.Compile = function (body) {
        return eval(body);
    };
    Expression.GetLambdaString = function (body, parameterExpressions) {
        var fn = "var compiledFunction = function(";
        for (var i = 0; i < parameterExpressions.length; i++) {
            fn += parameterExpressions[i].Name;
            if (i < parameterExpressions.length - 1) {
                fn += ", ";
            }
        }
        fn += ") {\r\n return " + body.Compile() + ";\r\n}\r\ncompiledFunction;";
        return fn;
    };
    return Expression;
}());
var ParameterExpression = /** @class */ (function (_super) {
    __extends(ParameterExpression, _super);
    function ParameterExpression(Type, Name) {
        var _this = _super.call(this) || this;
        _this.Type = Type;
        _this.Name = Name;
        _this.Func = function (context) { return context[Name]; };
        return _this;
    }
    ParameterExpression.prototype.Compile = function () {
        return this.Name;
    };
    return ParameterExpression;
}(Expression));
//exportx class LambdaExpression extends Expression {
//    public Parameters: ParameterExpression[];
//    constructor(public Body: Expression, ...parameters: ParameterExpression[]) {
//        super();
//        this.Parameters = parameters;
//    }
//}
var PropertyExpression = /** @class */ (function (_super) {
    __extends(PropertyExpression, _super);
    function PropertyExpression(Expression, PropertyName) {
        var _this = _super.call(this) || this;
        _this.Expression = Expression;
        _this.PropertyName = PropertyName;
        _this.Func = function (context) { return Expression.GetValue(context)[PropertyName]; };
        return _this;
    }
    PropertyExpression.prototype.Compile = function () {
        return this.Expression.Compile() + "." + this.PropertyName;
    };
    return PropertyExpression;
}(Expression));
var BinaryExpression = /** @class */ (function (_super) {
    __extends(BinaryExpression, _super);
    function BinaryExpression(Left, Right) {
        var _this = _super.call(this) || this;
        _this.Left = Left;
        _this.Right = Right;
        return _this;
    }
    return BinaryExpression;
}(Expression));
var AssignExpression = /** @class */ (function (_super) {
    __extends(AssignExpression, _super);
    function AssignExpression(Left, Right) {
        var _this = _super.call(this, Left, Right) || this;
        _this.Left = Left;
        _this.Right = Right;
        _this.Func = function (context) { return Left.Expression.GetValue(context)[Left.PropertyName] = Right.GetValue(context); };
        return _this;
    }
    AssignExpression.prototype.Compile = function () {
        return this.Left.Compile() + " = " + this.Right.Compile();
    };
    return AssignExpression;
}(BinaryExpression));
var AddExpression = /** @class */ (function (_super) {
    __extends(AddExpression, _super);
    function AddExpression(Left, Right) {
        var _this = _super.call(this, Left, Right) || this;
        _this.Left = Left;
        _this.Right = Right;
        _this.Func = function (context) { return Left.GetValue(context) + Right.GetValue(context); };
        return _this;
    }
    AddExpression.prototype.Compile = function () {
        return this.Left.Compile() + " + " + this.Right.Compile();
    };
    return AddExpression;
}(BinaryExpression));
var ConstantExpression = /** @class */ (function (_super) {
    __extends(ConstantExpression, _super);
    function ConstantExpression(Value) {
        var _this = _super.call(this) || this;
        _this.Value = Value;
        _this.Func = function (context) { return Value; };
        return _this;
    }
    ConstantExpression.prototype.Compile = function () {
        throw new Error("Method not implemented.");
    };
    return ConstantExpression;
}(Expression));

var JavaScript = /** @class */ (function () {
    function JavaScript() {
    }
    JavaScript.Eval = function (javascript) {
        return eval(javascript);
    };
    return JavaScript;
}());

var NotImplementedException = /** @class */ (function (_super) {
    __extends(NotImplementedException, _super);
    function NotImplementedException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NotImplementedException;
}(Error));

var NumberConversionResult = /** @class */ (function () {
    function NumberConversionResult(Success, Value) {
        this.Success = Success;
        this.Value = Value;
    }
    return NumberConversionResult;
}());

var NumberConverter = /** @class */ (function () {
    function NumberConverter() {
    }
    NumberConverter.TryConvert = function (value) {
        var result = new NumberConversionResult(false, 0);
        var asNumber = parseInt(value);
        if (!isNaN(asNumber)) {
            result.Value = asNumber;
            result.Success = true;
        }
        return result;
    };
    return NumberConverter;
}());

var Platform = /** @class */ (function () {
    function Platform() {
    }
    Platform.Name = "JavaScript";
    return Platform;
}());

var Regex = /** @class */ (function () {
    function Regex() {
    }
    Regex.Replace = function (input, pattern, replaceWith) {
        return input.replace(pattern, replaceWith);
    };
    return Regex;
}());

var StringComparison;
(function (StringComparison) {
    StringComparison[StringComparison["CurrentCulture"] = 0] = "CurrentCulture";
    StringComparison[StringComparison["CurrentCultureIgnoreCase"] = 1] = "CurrentCultureIgnoreCase";
    StringComparison[StringComparison["InvariantCulture"] = 2] = "InvariantCulture";
    StringComparison[StringComparison["InvariantCultureIgnoreCase"] = 3] = "InvariantCultureIgnoreCase";
    StringComparison[StringComparison["Ordinal"] = 4] = "Ordinal";
    StringComparison[StringComparison["OrdinalIgnoreCase"] = 5] = "OrdinalIgnoreCase";
})(StringComparison || (StringComparison = {}));

//TsExportIdentifier:Ts
var Ts = /** @class */ (function () {
    function Ts() {
    }
    Ts.Enumerable = new Enumerable();
    return Ts;
}());

function SafeCast(type, obj) {
    if (obj === null || obj === undefined) {
        return null;
    }
    if (type instanceof TypeContainer) {
        return SafeCast(type.type, obj);
    }
    var name = TypeInfo.NameOf(type);
    if (name === "String") {
        return typeof obj === "string" ? obj : null;
    }
    if (name === "Number") {
        return typeof obj === "number" ? obj : null;
    }
    return TypeInfo.IsAssignableFrom(type, TypeInfo.GetType(obj)) ? obj : null;
    //return obj instanceof type ? (obj as T) : null;
}
function SafeCastToInterface(obj, interfaceDefinition) {
    // TODO: Check if object type implements interface
    if (obj == null) {
        return null;
    }
    if (interfaceDefinition.Name === "IArray" && TypeInfo.IsArray(obj)) {
        return obj;
    }
    if (TypeInfo.GetIsAssignableFrom(interfaceDefinition, TypeInfo.GetType(obj))) {
        return obj;
    }
    return null;
}
function GetValueOf(obj) {
    if (typeof obj === 'object') {
        return obj;
    }
    return (obj === null || obj === undefined ? obj : obj.valueOf());
}

export { Activator, AddExpression, AssignExpression, BinaryExpression, BreakException, Coalesce, Collection, ConstantExpression, DateTime, DateUtil, DeepCloner, Dictionary, DictionaryItem, Enum, EnumValue, EnumValueCollection, Enumerable, EqualityComparer, Expression, ExpressionExtensions, GetValueOf, Guid, Interface, JavaScript, KeyValuePair, MapUtil, MethodInfo, NotImplementedException, Nullable, NumberConversionResult, NumberConverter, ObjectNullifier, ParameterExpression, Platform, Profiling, PropertyExpression, PropertyInfo, Regex, SafeCast, SafeCastToInterface, Serialization, StackTracePoint, StringBuilder, StringComparison, StringUtil, TryGetValueResult, Ts, TypeContainer, TypeInfo, TypeMetadata, TypeName, TypeOf, __defer, __deferred };
